//! This code was AUTOGENERATED using the codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

use borsh::{BorshDeserialize, BorshSerialize};
use system_program_sdk::instructions::advance_nonce_account::{
    AdvanceNonceAccount as AdvanceNonceAccountIxAccounts,
    AdvanceNonceAccountInstructionArgs as AdvanceNonceAccountIxData,
};
use system_program_sdk::instructions::allocate::{
    Allocate as AllocateIxAccounts, AllocateInstructionArgs as AllocateIxData,
};
use system_program_sdk::instructions::allocate_with_seed::{
    AllocateWithSeed as AllocateWithSeedIxAccounts,
    AllocateWithSeedInstructionArgs as AllocateWithSeedIxData,
};
use system_program_sdk::instructions::assign::{
    Assign as AssignIxAccounts, AssignInstructionArgs as AssignIxData,
};
use system_program_sdk::instructions::assign_with_seed::{
    AssignWithSeed as AssignWithSeedIxAccounts,
    AssignWithSeedInstructionArgs as AssignWithSeedIxData,
};
use system_program_sdk::instructions::authorize_nonce_account::{
    AuthorizeNonceAccount as AuthorizeNonceAccountIxAccounts,
    AuthorizeNonceAccountInstructionArgs as AuthorizeNonceAccountIxData,
};
use system_program_sdk::instructions::create_account::{
    CreateAccount as CreateAccountIxAccounts, CreateAccountInstructionArgs as CreateAccountIxData,
};
use system_program_sdk::instructions::create_account_with_seed::{
    CreateAccountWithSeed as CreateAccountWithSeedIxAccounts,
    CreateAccountWithSeedInstructionArgs as CreateAccountWithSeedIxData,
};
use system_program_sdk::instructions::initialize_nonce_account::{
    InitializeNonceAccount as InitializeNonceAccountIxAccounts,
    InitializeNonceAccountInstructionArgs as InitializeNonceAccountIxData,
};
use system_program_sdk::instructions::transfer_sol::{
    TransferSol as TransferSolIxAccounts, TransferSolInstructionArgs as TransferSolIxData,
};
use system_program_sdk::instructions::transfer_sol_with_seed::{
    TransferSolWithSeed as TransferSolWithSeedIxAccounts,
    TransferSolWithSeedInstructionArgs as TransferSolWithSeedIxData,
};
use system_program_sdk::instructions::upgrade_nonce_account::{
    UpgradeNonceAccount as UpgradeNonceAccountIxAccounts,
    UpgradeNonceAccountInstructionArgs as UpgradeNonceAccountIxData,
};
use system_program_sdk::instructions::withdraw_nonce_account::{
    WithdrawNonceAccount as WithdrawNonceAccountIxAccounts,
    WithdrawNonceAccountInstructionArgs as WithdrawNonceAccountIxData,
};

/// System Instructions
#[derive(Debug)]
pub enum SystemProgramIx {
    CreateAccount(CreateAccountIxAccounts, CreateAccountIxData),
    Assign(AssignIxAccounts, AssignIxData),
    TransferSol(TransferSolIxAccounts, TransferSolIxData),
    CreateAccountWithSeed(CreateAccountWithSeedIxAccounts, CreateAccountWithSeedIxData),
    AdvanceNonceAccount(AdvanceNonceAccountIxAccounts, AdvanceNonceAccountIxData),
    WithdrawNonceAccount(WithdrawNonceAccountIxAccounts, WithdrawNonceAccountIxData),
    InitializeNonceAccount(
        InitializeNonceAccountIxAccounts,
        InitializeNonceAccountIxData,
    ),
    AuthorizeNonceAccount(AuthorizeNonceAccountIxAccounts, AuthorizeNonceAccountIxData),
    Allocate(AllocateIxAccounts, AllocateIxData),
    AllocateWithSeed(AllocateWithSeedIxAccounts, AllocateWithSeedIxData),
    AssignWithSeed(AssignWithSeedIxAccounts, AssignWithSeedIxData),
    TransferSolWithSeed(TransferSolWithSeedIxAccounts, TransferSolWithSeedIxData),
    UpgradeNonceAccount(UpgradeNonceAccountIxAccounts, UpgradeNonceAccountIxData),
}

#[derive(Debug, Copy, Clone)]
pub struct InstructionParser;

impl yellowstone_vixen_core::Parser for InstructionParser {
    type Input = yellowstone_vixen_core::InstructionUpdate;
    type Output = SystemProgramIx;

    fn id(&self) -> std::borrow::Cow<str> {
        "System::InstructionParser".into()
    }

    fn prefilter(&self) -> yellowstone_vixen_core::Prefilter {
        yellowstone_vixen_core::Prefilter::builder()
            .program_ids([crate::SYSTEM_ID])
            .build()
            .unwrap()
    }

    async fn parse(
        &self,
        ix_update: &InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<Self::Output> {
        if ix_update.program.equals_ref(crate::SYSTEM_ID) {
            InstructionParser::parse_impl(ix_update)
        } else {
            Err(yellowstone_vixen_core::ParseError::Filtered)
        }
    }
}

impl ProgramParser for InstructionParser {
    #[inline]
    fn program_id(&self) -> yellowstone_vixen_core::Pubkey {
        crate::SYSTEM_ID.to_bytes().into()
    }
}

impl InstructionParser {
    pub(crate) fn parse_impl(
        ix: &InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<SystemProgramIx> {
        let accounts_len = ix.accounts.len();
        let ix_discriminator: [u8; 1] = ix.data[0..1].try_into()?;
        let mut ix_data = &ix.data[1..];

        match ix_discriminator {
            0 => {
                check_min_accounts_req(accounts_len, 2)?;
                let de_ix_data: CreateAccountIxData = BorshDeserilaize::deserialize(&mut ix_data)?;
                let ix_accounts = CreateAccountIxAccounts {
                    payer: ix.accounts[0],
                    new_account: ix.accounts[1],
                };
                Ok(SystemProgramIx::CreateAccount(ix_accounts, de_ix_data))
            }
            1 => {
                check_min_accounts_req(accounts_len, 1)?;
                let de_ix_data: AssignIxData = BorshDeserilaize::deserialize(&mut ix_data)?;
                let ix_accounts = AssignIxAccounts {
                    account: ix.accounts[0],
                };
                Ok(SystemProgramIx::Assign(ix_accounts, de_ix_data))
            }
            2 => {
                check_min_accounts_req(accounts_len, 2)?;
                let de_ix_data: TransferSolIxData = BorshDeserilaize::deserialize(&mut ix_data)?;
                let ix_accounts = TransferSolIxAccounts {
                    source: ix.accounts[0],
                    destination: ix.accounts[1],
                };
                Ok(SystemProgramIx::TransferSol(ix_accounts, de_ix_data))
            }
            3 => {
                check_min_accounts_req(accounts_len, 3)?;
                let de_ix_data: CreateAccountWithSeedIxData =
                    BorshDeserilaize::deserialize(&mut ix_data)?;
                let ix_accounts = CreateAccountWithSeedIxAccounts {
                    payer: ix.accounts[0],
                    new_account: ix.accounts[1],
                    base_account: ix.accounts[2],
                };
                Ok(SystemProgramIx::CreateAccountWithSeed(
                    ix_accounts,
                    de_ix_data,
                ))
            }
            4 => {
                check_min_accounts_req(accounts_len, 3)?;
                let de_ix_data: AdvanceNonceAccountIxData =
                    BorshDeserilaize::deserialize(&mut ix_data)?;
                let ix_accounts = AdvanceNonceAccountIxAccounts {
                    nonce_account: ix.accounts[0],
                    recent_blockhashes_sysvar: ix.accounts[1],
                    nonce_authority: ix.accounts[2],
                };
                Ok(SystemProgramIx::AdvanceNonceAccount(
                    ix_accounts,
                    de_ix_data,
                ))
            }
            5 => {
                check_min_accounts_req(accounts_len, 5)?;
                let de_ix_data: WithdrawNonceAccountIxData =
                    BorshDeserilaize::deserialize(&mut ix_data)?;
                let ix_accounts = WithdrawNonceAccountIxAccounts {
                    nonce_account: ix.accounts[0],
                    recipient_account: ix.accounts[1],
                    recent_blockhashes_sysvar: ix.accounts[2],
                    rent_sysvar: ix.accounts[3],
                    nonce_authority: ix.accounts[4],
                };
                Ok(SystemProgramIx::WithdrawNonceAccount(
                    ix_accounts,
                    de_ix_data,
                ))
            }
            6 => {
                check_min_accounts_req(accounts_len, 3)?;
                let de_ix_data: InitializeNonceAccountIxData =
                    BorshDeserilaize::deserialize(&mut ix_data)?;
                let ix_accounts = InitializeNonceAccountIxAccounts {
                    nonce_account: ix.accounts[0],
                    recent_blockhashes_sysvar: ix.accounts[1],
                    rent_sysvar: ix.accounts[2],
                };
                Ok(SystemProgramIx::InitializeNonceAccount(
                    ix_accounts,
                    de_ix_data,
                ))
            }
            7 => {
                check_min_accounts_req(accounts_len, 2)?;
                let de_ix_data: AuthorizeNonceAccountIxData =
                    BorshDeserilaize::deserialize(&mut ix_data)?;
                let ix_accounts = AuthorizeNonceAccountIxAccounts {
                    nonce_account: ix.accounts[0],
                    nonce_authority: ix.accounts[1],
                };
                Ok(SystemProgramIx::AuthorizeNonceAccount(
                    ix_accounts,
                    de_ix_data,
                ))
            }
            8 => {
                check_min_accounts_req(accounts_len, 1)?;
                let de_ix_data: AllocateIxData = BorshDeserilaize::deserialize(&mut ix_data)?;
                let ix_accounts = AllocateIxAccounts {
                    new_account: ix.accounts[0],
                };
                Ok(SystemProgramIx::Allocate(ix_accounts, de_ix_data))
            }
            9 => {
                check_min_accounts_req(accounts_len, 2)?;
                let de_ix_data: AllocateWithSeedIxData =
                    BorshDeserilaize::deserialize(&mut ix_data)?;
                let ix_accounts = AllocateWithSeedIxAccounts {
                    new_account: ix.accounts[0],
                    base_account: ix.accounts[1],
                };
                Ok(SystemProgramIx::AllocateWithSeed(ix_accounts, de_ix_data))
            }
            10 => {
                check_min_accounts_req(accounts_len, 2)?;
                let de_ix_data: AssignWithSeedIxData = BorshDeserilaize::deserialize(&mut ix_data)?;
                let ix_accounts = AssignWithSeedIxAccounts {
                    account: ix.accounts[0],
                    base_account: ix.accounts[1],
                };
                Ok(SystemProgramIx::AssignWithSeed(ix_accounts, de_ix_data))
            }
            11 => {
                check_min_accounts_req(accounts_len, 3)?;
                let de_ix_data: TransferSolWithSeedIxData =
                    BorshDeserilaize::deserialize(&mut ix_data)?;
                let ix_accounts = TransferSolWithSeedIxAccounts {
                    source: ix.accounts[0],
                    base_account: ix.accounts[1],
                    destination: ix.accounts[2],
                };
                Ok(SystemProgramIx::TransferSolWithSeed(
                    ix_accounts,
                    de_ix_data,
                ))
            }
            12 => {
                check_min_accounts_req(accounts_len, 1)?;
                let de_ix_data: UpgradeNonceAccountIxData =
                    BorshDeserilaize::deserialize(&mut ix_data)?;
                let ix_accounts = UpgradeNonceAccountIxAccounts {
                    nonce_account: ix.accounts[0],
                };
                Ok(SystemProgramIx::UpgradeNonceAccount(
                    ix_accounts,
                    de_ix_data,
                ))
            }
            _ => Err(yellowstone_vixen_core::ParseError::from(
                "Invalid Instruction discriminator".to_owned(),
            )),
        }
    }
}
